# Swax/Entitites

Swax/Entites - альтернатива React state management библиотекам вроде Redux, MobX, Recoil, Jotai и другим. Большинство подобных библиотек предоставляют слишком абстрактные механизмы работы с состояниями, требующими наполнения конкретными решениями. В отличие от них, Swax ориентирован на практическое применение и содержит как многоуровневый набор абстракций, так и практические решения большинства типовых задач, так или иначе связанных с управлением состояниями. Swax создан для быстрого создания приложений, позволяющего сохранять высокий темп разработки, логичноcть, простоту и гармоничность кода приложений любого масштаба.

Важно отметить, что Swax в целом не использует HOC и "магию". Он основан на обычных хуках React. Также Swax исповедует `configuration over code`, используя декларативный подход везде, где это возможно.

## Сущность

Понятие сущности лежит в основе Swax. Сущность - это, как правило, бизнес-модель либо модель состояния приложения. В рамках Swax любая сущность - это экземпляр какого-либо класса, отображающего конкретную модель. Нет никаких особых ограничений или базовых классов, от которых класс сущности должен быть отнаследован. Например:

```typescript
class User {
  constructor(name: string = null, surname: string = null) {
    this.name = name;
    this.surname = surname;
  }
  id: number | null = null;
  name: string | null;
  surname: string | null;
  email: string | null = null;
  roles: string[] = [];
}
```

Используем хук `useEntity()`, чтобы получить сущность из класса `User`:
```typescript
const [user, setUser] = useEntity(User);
```

Декларация хука `useEntity()`:

```typescript
declare function useEntity<Entity>(entityClass: EntityConstructor<Entity>, ...initialArgs: any[]): [Readonly<Entity>, EntityUpdater];
```
Из нее видно, что хук принимает конструктор класса и начальные аргументы, передаваемые в конструктор, и возвращает кортеж из готовой сущности и ее функции-апдейтера.

Одной из основных особенностей сущности является то, что она иммутабельна. Попытки изменить значения ее атрибутов напрямую приводят к выбросу исключения. Для обновления ее состояния используется функция-апдейтер, получаемая в кортеже вместе с сущностью. Кроме того, существует хук `useUpdater()`, который возвращает функцию-апдейтер отдельно, а также может создавать апдейтеры с ограниченным набором обновляемых аргументов (restricted updater). Такие апдейтеры полезны для передачи дочерним компонентам. Это будет гарантировать, что они смогут изменять только те атрибуты, которые они используют (за которые несут ответственность). Например, следующий апдейтер будет обновлять только атрибут `name`, остальные передаваемые атрибуты будут игнорироваться:

```typescript
const [user] = useEntity(User);
const setUserName = useUpdater(user, ['name']);
...
setUserName({name: 'John', surname: 'Doe'}); // Обновляет только user.name = 'John'
console.log(user.name, user.surname) // 'John', null
```

Функция-апдейтер создает новый иммутабельный экземпляр сущности, перенося в него старые значения и объединяя их с новыми, после чего вызывет перерисовку компонента. В отличие от классического `setState()` апдейтер не тебует передачи всего нового состояния, а только лишь обновленной части, выполняя сведение состояний самостоятельно, лишая разработчика необходимости в кастомных редьюсерах.

Существует также облегченная readonly-версия хука сущности - `useReadonlyEntity()` - возвращающая текущее мастер-состояние сущности и не давая никаких инструментов для ее модификации.

Важно отметить, что классы сущностей могут иметь методы. Однако они должны быть чистыми (не вызывать сайд-эффектов) и не пытаться обновлять состояние сущности.

## Master State

Еще одной ключевой особенностью любой сущности является наличие мастер-состояния. Технически любая сущность состоит из двух замороженных объектов, один из которых содержит текущее обновленное состояние, а его прототип указывает на второй замороженный объект, содержащий т. н. мастер-состояние. Изначально, при создании сущности с помощью `useEntity()`, создается мастер с начальными значениями, к которому крепится через прототип пустой объект. При последующих изменениях сущности с помощью апдейтеров второй объект наполняется значениями, мастер-объект при этом остается неизменным. Благодаря связке через прототип, итоговые значения атрибутов сущности получаются путем накладывания значений текущего состояния на мастер. При этом недостающие в текущем состоянии значения прозрачным образом извлекаются из мастера.

Наличие мастер-состояния дает следующие возможности:

- откатить текущее состояние к мастеру (очистив текущее состояние).
- разделить мастер-состояние между потребителями (текущими состояниями в разных компонентах), гарантирующее, что изменения, вносимые каждым из них, не будут оказывать влияние на мастер, пока не будет выполнен коммит.

Чтобы откатить текущее состояние к мастеру, достаточно вызвать апдейтер с `null`:
```typescript
const [user, setUser] = useEntity(User, 'John', 'Doe');
console.log(user); // {name: 'John', surname: 'Doe'}
...
setUser({name: 'Sarah', surname: 'Connor'});
console.log(user); // {name: 'Sarah', surname: 'Connor'}
...
setUser(null);
console.log(user); // {name: 'John', surname: 'Doe'}
```

Текущее мастер-состояние можно получить, просто взяв прототип сущности:
```typescript
const master = Object.getPrototypeOf(user);
```
Либо использовать для этого хук `useMaster(entity: Entity): Readonly<Entity>`, который делает, по сути, то же самое, но выглядит более семантично:
```typescript
const master = useMaster(user);
```

Чтобы закрепить текущее состояние в мастере, нужно получить функцию-коммиттер с помощью хука `useCommitter()` и вызвать ее. В результате этого, текущее состояние будет скопировано в мастер, а само оно будет полностью очищено. С позиции общего набора значений сущности изменений не произойдет, просто значения перераспределятся между состояниями (полностью уйдут в мастер):
```typescript
const [user, setUser] = useEntity(User);
const commitUser = useCommitter(user);
...
setUser({name: 'John', surname: 'Doe'});
const master = useMaster(user);
console.log(user);                                     // {name: 'John', surname: 'Doe'}
console.log(master);                                   // {name: null, surname: null}
...
commitUser();
console.log(user);                                     // {name: 'John', surname: 'Doe'}
console.log(Object.fromEntries(Object.entries(user))); // {}
console.log(master);                                   // {name: 'John', surname: 'Doe'}
```
> Этот и последующие примеры достаточно условны - разумеется, в действительности, весь код выполняется в контексте компонента, и казждый вызов функций, меняющих состояние сущности или ее аспектов, вызывает его перерендер (если не брать во внимание батчинг).


# Аспекты

Если бы Swax ограничился возможностями, описанными выше, то он немногим бы отличался от распространенных библиотек для React state management. Однако именно аспекты дают сущностям замечательные практические механизмы, избавляя разработчика от необходимости каждый раз решать наиболее типовые задачи, связанные с бизнес-моделями и бизнес-логикой.

Аспекты - это "плагины" или "микросервисы" для сущностей. Аспекты добавляют новые уровни абстракции над сущностью. Сущность ничего не знает о своих аспектах. Прикрепление аспектов к ней происходит одномоментно, при описании класса сущости, с помощью декораторов, оборачивающих класс. Аспекты, как правило, также не должны ничего знать друг о друге, за исключением аспектов, использующих или расширяющих какие-то другие конкретные аспекты. Такой подход позволяет максимально отделить все абстракции друг от друга, разделяя ответственности и снижая связанности до минимума.

Разработчики могут использовать существующие аспекты, расширять их, а также создавать свои собственные.

Для работы с аспектами используются хуки `useAspect()` и `useAction()`. 

- `useAspect(entity: Entity, aspect: Aspect): AspectState | null` возвращает текущее состояние аспекта (если оно у него есть).

- `useAction(entity: Entity, actionName: string): AspectAction` возвращает т. н. действие - некую обобщенную асинхронную операцию, которую можно выполнить над сущностью в хуке эффекта. Действия (экшены) объявляются в рамках того или иного аспекта и используют их механики. Подробнее о действиях - в соответствующем разделе.

## StateStack

Примером простейшего аспекта является StateStack. Он добавляет к сущности стек состояний заданной длины. Текущее мастер-состояние сущности находится на вершине стека состояния. При каждом коммите старый мастер передвигается глубже в стек, на вершину которого помещается новый мастер. Аспект StateStack может быть полезен, например, при реализации паттерна `Command`.

Аспект реализует три собственных хука:

- `useRollback(entity: Entity): (index?: number) => void` - возвращает функцию, откатывающую последний мастер, заменяя его мастером с указанным индексом из стека. При этом, все состояния до указанного удаляются из стека. Если индекс не указан, текущий мастер заменяется предпоследним.
- `usePickState(entity: Entity): (index: number) => void` - возвращает функцию, заменяющую текущий мастер на указанный мастер из стека. Выбранный мастер удаляется с текущей позиции.
- `useFlushStack(entity: Entity): () => void` - возвращает функцию, очищающую стек состояний, оставляя текущий мастер на вершине стека.

Хук `useAspect()` возвращает текущий стек состояний в виде иммутабельного массива.


```typescript
import { useEntity, useCommitter, useAspect } from '@swax/entities';
import StateStack, { stateStack, useRollback, useFlushStack } from '@swax/entities/aspects/StateStack';

@stateStack({
    size: 10
})
class User {
  name: string | null = null;
  surname: string | null = null;
}

...
const [user, setUser] = useEntity(User);
const commitUser = useCommitter(user);
const userStack = useAspect(user, StateStack);
const rollbackUser = useRollback(user);
const flushUserStack = useFlushStack(user);

setUser({name: 'Joe', surname: 'Doe'});
commitUser();
...
setUser({name: 'Sarah', surname: 'Connor'});
commitUser();
...
setUser({name: 'John'});
commitUser();
...
console.log(user);         // {name: 'John', surname: 'Connor'},
console.log(userStack);
//  [
//    {name: 'Joe', surname: 'Doe'}
//    {name: 'Sarah', surname: 'Connor'},
//    {name: 'John', surname: 'Connor'},
//  ]
...
rollbackUser();
console.log(user);         // {name: 'Sarah', surname: 'Connor'},
console.log(userStack);
//  [
//    {name: 'Joe', surname: 'Doe'}
//    {name: 'Sarah', surname: 'Connor'},
//  ]
...
flushUserStack();
console.log(user);         // {name: 'Joe', surname: 'Doe'},
console.log(userStack);
//  [
//    {name: 'Joe', surname: 'Doe'}
//  ]
```

## Schema

Аспект Schema позволяет описать схему свойств сущности. Можно задать первичный ключ сущности, базовые типы свойств и ограничения, накладываемые на каждое свойство. При каждом изменении свойства апдейтером новое значение будет прогоняться через набор ограничений и будет допущено к обновлению только в том случае, если оно проходит хотя бы одну группу валидационных ограничений. Можно создавать собственные ограничения. Также можно указывать вторичные ключи, при изменении которых возможна подгрузка связанных сущностей (реализация в рамках аспекта Replica)

Аспект будет полезен, например, при автоматическом построении форм для произвольной сущности или для клиентской валидации.

```typescript
import Schema, { schema, property, arrayProperty, objectProperty } from '@swax/entities/aspects/Schema';
import { Nullable, PositiveInteger, NonZero, Length, FirstUpperCase, Email } from '@swax/entities/aspects/Schema/constrains';

@schema({
    key: 'id'
})
class User {
  @property(Number, [Nullable], [PositiveInteger, NonZero])
  id: number | null = null;

  @property(String, [Nullable], [Length(32), FirstUpperCase])
  name: string | null = null;

  @property(String, [Nullable], [Length(64), FirstUpperCase])
  surname: string | null = null;

  @property(String, [Nullable], [Length(32), Email])
  email: string | null = null;

  @property(Boolean)
  isActive: boolean = false;

  @arrayProperty(String)
  roles: string[] = [];

  @objectProperty()
  settings: UserSettings = {};
}
...
const [user] = useEntity(User);
const userSchema = useAspect(user, Schema);
console.log(userSchema.key);                       // ['id']
console.log(userSchema.properties.id.baseType);    // Number
console.log(userSchema.properties.id.constrains);  // [[Nullable], [PositiveInteger, NonZero]]
```
Важно отметить, что аспект Schema создает собственное иммутабельное состояние, содержащее описание схемы сущности, и оно разделяется между всеми экземплярами данного класса сущности, хранясь в прототипе конструктора сущности.

## Validation

Аспект Validation представляет собой пример аспекта, расширяющего возможности другого аспекта - Schema. Он создает для сущности отдельное состояние, доступное через `useAspect()`, которое может хранить сообщения о нарушении валидации в свойствах сущности. Validation может отключать режим отмены обновления при нарушениях ограничений Schema, разрешая обновляться невалидными значениями, занося при этом сообщения от нарушенных ограничителей в одноименные поля собственного состояния. Настройки режимов можно производить отдельно для каждого свойства.

Также используется аспектом Replica, позволяя устанавливать валидационные сообщения, приходящие от сервера, в ответ на попытку удаленно обновить сущность новыми значениями.

Поддерживает ряд собственных хуков, например `useSetValidation()`, устанавливающий валидационное сообщение напрямую, или `useFlushValidation()`, сбрасывающий состояние валидации сущности.

```typescript
@replica(...)
@validation(...)
class User {
  name: string | null = null;
  surname: string | null = null;
  loginTimeout: number = 0;
}

...
const [user, setUser] = useEntity(User);
const tryUpdateUser = useAction(user, 'update');
const validation = useAspect(user, Validation);
...
setUser({name: 'Joe', surname: 'Doe', loginTimeout: 99999});
console.log(validation);    // null
// отправляем текущее состояние на сервер (с помощью экшена аспекта Replica):
tryUpdateUser();
...
// через некоторое время, после получения ответа от сервера,
// состояние validation самостоятельно обновится и вызовет перерендер компонента:
console.log(validation);    // {loginTimeout: 'loginTimeout must be less or equal 600'},
```

## EntityStore

> TODO: подробно расписать с примерами

- Хранит мастер-состояния, разделяемые между сущностями. Обновление мастера в сторе вызывает обновления всех сущностей, разделяющих мастер.
- Требует наличия первичного ключа у сущностей (нужна Schema с key).
- Кеширует состояния при запросах на сервер - если сущность недавно уже запрашивалась, и ttl не просрочен - Replica может брать сущность из стора, без повторного запроса на сервер.
- Поддерживает коллекции сущностей.

## Replica

> TODO: подробно расписать с примерами

- Самый обширный аспект. Основная идея: текущая сущность - это реплика (копия) данных, хранимых где-то еще, как правило, за пределами приложения.
- Источником данных для реплики является абстрактный DataSource. Конкретные его реализации могут включать RemoteServer, LocalStorage, IndexedDB и прочее. У реплики может быть несколько источников данных одновременно.
- Основная функция - синхронизация текущей сущности и ее исходной сущности (source entity).
- Полная и прозрачная поддержка как CRUD-действий над сущностью, так и любых кастомных запросов.
- Каждый эндпоинт описывается отдельным экшеном в рамках декоратора `@replica`, оборачивающего класс сущности.
- Экшен может включать в себя url или key для запроса, билдер тела запроса, парсер ответа, дополнительные опции.
- Url/key запроса поддерживает автомаппинг - автоматически подставляет значения из сущности в паттерны url/key.
- Поддерживает автобайндинг по внешнему ключу для сущностей - подгружает нужные сущности при изменении внешнего ключа.
- Поддержка единого глобального конфига, содержащего общие дефолтные настройки, стратегии и методы, снижающего количество повторяемых деклараций в конфигах реплик.
- +++ 
# Коллекции сущностей

> TODO: подробно расписать с примерами

- Иммутабельная массивоподобная структура, содержащая мастер-состояния сущностей.
- Требует наличия первичного ключа у сущностей (нужна Schema с key).
- Итерабельна, хранит порядок расположения сущностей, быстрый доступ по индексу и по ключу.
- Создается отдельным хуком.
- Может быть связана со стором (хранит мастера сущностей в сторе), разделяет мастер-состояния с другими компонентами.
- Может быть получена из Replica как ответ на запрос через экшен.